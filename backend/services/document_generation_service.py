"""
Document generation service for creating downloadable files with progress streaming
"""

from datetime import datetime
import os
import uuid
import tempfile
import time
import json
from docxtpl import DocxTemplate
import io


class DocumentGenerationService:
    """Handles document file generation from section data with progress callbacks"""
    
    def __init__(self, uploaded_templates=None):
        self.uploaded_templates = uploaded_templates or {}
    
    def generate_txt_document_with_progress(self, document_id: str, document_data: dict, sections: list, progress_callback=None):
        """
        Generate a formatted text document from document data and sections with progress updates
        
        Args:
            document_id: The document ID from the lookup
            document_data: Dictionary of document metadata
            sections: List of completed sections with draft content
            progress_callback: Function to call with progress updates
            
        Returns:
            Formatted text content as string
        """
        def send_status(status: str, message: str, progress: int = 0):
            if progress_callback:
                progress_callback(status, message, progress)
        
        send_status("validating", "Validating sections...", 10)
        time.sleep(0.5)  # Simulate some processing time
        
        if not sections:
            send_status("error", "No completed sections found", 0)
            return None
        
        send_status("preparing", "Preparing document structure...", 20)
        time.sleep(0.3)
        
        content_lines = []
        
        # Document header
        send_status("header", "Creating document header...", 30)
        content_lines.append("=" * 60)
        content_lines.append(f"DOCUMENT: {document_id}")
        content_lines.append(f"GENERATED: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        content_lines.append("=" * 60)
        content_lines.append("")
        
        # Document metadata section
        if document_data:
            send_status("metadata", "Adding document information...", 40)
            content_lines.append("DOCUMENT INFORMATION")
            content_lines.append("-" * 30)
            content_lines.append("")
            
            for field, value in document_data.items():
                content_lines.append(f"{field}: {value}")
            
            content_lines.append("")
            content_lines.append("=" * 60)
            content_lines.append("")
            time.sleep(0.3)
        
        # Process each section
        section_progress_start = 50
        section_progress_range = 40  # 50% to 90%
        
        for i, section in enumerate(sections):
            section_name = section.get('name', 'Untitled Section')
            section_draft = section.get('data', {}).get('draft', '')
            section_type = section.get('type', 'default')
            
            if not section_draft.strip():
                continue
            
            # Calculate progress for this section
            section_progress = section_progress_start + int((i / len(sections)) * section_progress_range)
            send_status("processing", f"Processing {section_name} section...", section_progress)
            
            # Section header
            content_lines.append(section_name.upper())
            content_lines.append("=" * len(section_name))
            content_lines.append("")
            
            # Clean and format section content with section type context
            cleaned_content = self._clean_section_content(section_draft, section_type)
            content_lines.append(cleaned_content)
            
            content_lines.append("")
            content_lines.append("-" * 40)
            content_lines.append("")
            
            time.sleep(0.4)  # Simulate processing time per section
        
        # Document footer
        send_status("finalizing", "Finalizing document...", 90)
        content_lines.append("=" * 60)
        content_lines.append("Generated by CRAFT - Document Planning & Drafting")
        content_lines.append("https://github.com/your-repo/craft")
        content_lines.append("=" * 60)
        
        time.sleep(0.3)
        
        final_content = "\n".join(content_lines)
        send_status("complete", "Document generation complete!", 100)
        
        return final_content
    
    def generate_docx_document_with_progress(self, document_id: str, document_data: dict, sections: list, progress_callback=None, template_info=None):
        """
        Generate a Word document from document data and sections with progress updates
        
        Args:
            document_id: The document ID from the lookup
            document_data: Dictionary of document metadata
            sections: List of completed sections with draft content
            progress_callback: Function to call with progress updates
            template_info: Dictionary with template information (type, name, etc.)
            
        Returns:
            BytesIO object containing the Word document
        """
        def send_status(status: str, message: str, progress: int = 0):
            if progress_callback:
                progress_callback(status, message, progress)
        
        send_status("validating", "Validating sections...", 10)
        time.sleep(0.5)
        
        if not sections:
            send_status("error", "No completed sections found", 0)
            return None
        
        send_status("loading", "Loading Word template...", 20)
        time.sleep(0.3)
        
        try:
            # Load the template based on template_info
            if template_info and template_info.get('type') == 'custom':
                # Look for uploaded template in memory
                template_name = template_info.get('name', '')
                template_found = False
                
                for template_key, template_data in self.uploaded_templates.items():
                    if template_data.get('filename') == template_name:
                        # Load template from memory
                        template_content = template_data['content']
                        doc = DocxTemplate(io.BytesIO(template_content))
                        template_found = True
                        send_status("loading", f"Loading custom template: {template_name}", 20)
                        break
                
                if not template_found:
                    send_status("error", f"Custom template '{template_name}' not found in memory", 0)
                    return None
            else:
                # Load default template - try template-tagged.docx first, then fallback to other names
                template_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'template-tagged.docx')
                if not os.path.exists(template_path):
                    # Fallback to alternative template names
                    template_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'template-tagged.docx.docx')
                    if not os.path.exists(template_path):
                        template_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'template-tagged-v2.docx')
                
                doc = DocxTemplate(template_path)
                send_status("loading", "Loading default template", 20)
            send_status("preparing", "Preparing document context...", 30)
            
            # Create context dictionary with template tags
            context = {}
            
            # Process each section
            section_progress_start = 40
            section_progress_range = 40  # 40% to 80%
            
            for i, section in enumerate(sections):
                section_name = section.get('name', 'Untitled Section')
                section_draft = section.get('data', {}).get('draft', '')
                section_type = section.get('type', 'default')
                template_tag = section.get('templateTag')
                
                if not section_draft.strip():
                    continue
                
                # Calculate progress for this section
                section_progress = section_progress_start + int((i / len(sections)) * section_progress_range)
                send_status("processing", f"Processing {section_name} section...", section_progress)
                
                # Use template tag directly from section data
                if template_tag and template_tag.strip():
                    # Clean and format section content
                    cleaned_content = self._clean_section_content(section_draft, section_type)
                    context[template_tag.strip()] = cleaned_content
                else:
                    send_status("processing", f"Skipping {section_name} - no template tag", section_progress)
                
                time.sleep(0.3)
            
            send_status("rendering", "Rendering Word document...", 80)
            time.sleep(0.5)
            
            # Render the document with context
            doc.render(context)
            
            # Save to BytesIO
            doc_buffer = io.BytesIO()
            doc.save(doc_buffer)
            doc_buffer.seek(0)
            
            send_status("complete", "Document generation complete!", 100)
            return doc_buffer
            
        except Exception as e:
            send_status("error", f"Failed to generate document: {str(e)}", 0)
            return None
    
    def generate_docx_document(self, document_id: str, document_data: dict, sections: list, template_info=None):
        """
        Generate a Word document from document data and sections (legacy method)
        """
        return self.generate_docx_document_with_progress(document_id, document_data, sections, None, template_info)
    
    def generate_txt_document(self, document_id: str, document_data: dict, sections: list) -> str:
        """
        Generate a formatted text document from document data and sections (legacy method)
        """
        return self.generate_txt_document_with_progress(document_id, document_data, sections, None)
    
    def _clean_section_content(self, content: str, section_type: str = 'default') -> str:
        """
        Clean section content by removing generation markers and formatting
        
        Args:
            content: Raw section draft content
            section_type: Type of section for appropriate formatting
            
        Returns:
            Cleaned and formatted content
        """
        # Check if content is JSON (for model_limitations and model_risk_issues sections)
        try:
            table_data = json.loads(content)
            if 'rows' in table_data:
                # Format table data as a text table with appropriate columns
                return self._format_table_as_text(table_data, section_type)
        except (json.JSONDecodeError, TypeError):
            # Not JSON, process as regular text
            pass
        
        lines = content.split('\n')
        cleaned_lines = []
        
        for line in lines:
            # Remove generation markers like [Generated draft - review and refine as needed]
            if line.strip().startswith('[') and line.strip().endswith(']'):
                continue
            
            # Clean any other markers
            cleaned_line = line.strip()
            if cleaned_line:
                cleaned_lines.append(cleaned_line)
            elif cleaned_lines and cleaned_lines[-1]:  # Preserve paragraph breaks
                cleaned_lines.append("")
        
        # Join with proper paragraph spacing
        formatted_content = []
        for i, line in enumerate(cleaned_lines):
            if line == "":
                if formatted_content and formatted_content[-1] != "":
                    formatted_content.append("")
            else:
                formatted_content.append(line)
        
        return "\n".join(formatted_content)
    
    def _format_table_as_text(self, table_data: dict, section_type: str = 'table') -> str:
        """
        Format table JSON data as a text table
        
        Args:
            table_data: Dictionary with 'rows' containing table data
            section_type: Type of section ('model_limitations' for limitations, 'model_risk_issues' for risk issues)
            
        Returns:
            Formatted text table
        """
        if not table_data.get('rows'):
            return "Empty table"
        
        # Define column headers, keys, and widths based on section type
        if section_type == 'model_risk_issues':
            # Model Risk Issues columns: (display_name, json_key, width)
            columns = [
                ('Risk Issue', 'item', 25),
                ('Description', 'description', 40),
                ('Likelihood', 'quantity', 12),
                ('Risk Level', 'status', 12),
                ('Controls', 'notes', 30)
            ]
        else:
            # Model Limitations columns (default): (display_name, json_key, width)
            columns = [
                ('Limitation', 'item', 25),
                ('Description', 'description', 40),
                ('Severity', 'quantity', 10),
                ('Impact', 'status', 15),
                ('Mitigation', 'notes', 30)
            ]
        
        lines = []
        
        # Calculate the maximum width needed for each column
        column_widths = []
        for col_name, col_key, min_width in columns:
            # Start with header width and minimum width
            max_width = max(len(col_name), min_width)
            # Check all data values for this column
            for row in table_data['rows']:
                value = str(row.get(col_key, '-'))
                max_width = max(max_width, len(value))
            column_widths.append(max_width)
        
        # Create header row
        header = "|"
        separator = "|"
        for i, (col_name, col_key, min_width) in enumerate(columns):
            width = column_widths[i]
            header += f" {col_name.ljust(width)} |"
            separator += "-" * (width + 2) + "|"
        
        lines.append(header)
        lines.append(separator)
        
        # Add data rows
        for row in table_data['rows']:
            row_line = "|"
            for i, (col_name, col_key, min_width) in enumerate(columns):
                width = column_widths[i]
                value = str(row.get(col_key, '-'))
                row_line += f" {value.ljust(width)} |"
            lines.append(row_line)
        
        # Add footer with row count
        lines.append(separator)
        lines.append(f"Total rows: {len(table_data['rows'])}")
        
        return "\n".join(lines)
    
    def create_temporary_file(self, content: str, document_id: str) -> str:
        """
        Create a temporary file with the document content
        
        Args:
            content: The document content
            document_id: Document ID for filename
            
        Returns:
            Path to the temporary file
        """
        # Create a temporary file
        fd, temp_path = tempfile.mkstemp(suffix='.txt', prefix=f'document_{document_id}_')
        
        try:
            with os.fdopen(fd, 'w', encoding='utf-8') as temp_file:
                temp_file.write(content)
            return temp_path
        except Exception as e:
            # Clean up the file descriptor if writing fails
            os.close(fd)
            raise e
    
    def get_filename(self, document_id: str, file_type: str = 'docx') -> str:
        """
        Generate a filename for the document
        
        Args:
            document_id: The document ID
            file_type: File extension (docx or txt)
            
        Returns:
            Suggested filename
        """
        safe_id = "".join(c for c in document_id if c.isalnum() or c in ('-', '_'))
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        return f"document_{safe_id}_{timestamp}.{file_type}"