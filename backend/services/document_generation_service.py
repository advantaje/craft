"""
Document generation service for creating downloadable files with progress streaming
"""

from datetime import datetime
import os
import uuid
import tempfile
import time
import json


class DocumentGenerationService:
    """Handles document file generation from section data with progress callbacks"""
    
    def __init__(self):
        pass
    
    def generate_txt_document_with_progress(self, document_id: str, document_data: dict, sections: list, progress_callback=None):
        """
        Generate a formatted text document from document data and sections with progress updates
        
        Args:
            document_id: The document ID from the lookup
            document_data: Dictionary of document metadata
            sections: List of completed sections with draft content
            progress_callback: Function to call with progress updates
            
        Returns:
            Formatted text content as string
        """
        def send_status(status: str, message: str, progress: int = 0):
            if progress_callback:
                progress_callback(status, message, progress)
        
        send_status("validating", "Validating sections...", 10)
        time.sleep(0.5)  # Simulate some processing time
        
        if not sections:
            send_status("error", "No completed sections found", 0)
            return None
        
        send_status("preparing", "Preparing document structure...", 20)
        time.sleep(0.3)
        
        content_lines = []
        
        # Document header
        send_status("header", "Creating document header...", 30)
        content_lines.append("=" * 60)
        content_lines.append(f"DOCUMENT: {document_id}")
        content_lines.append(f"GENERATED: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        content_lines.append("=" * 60)
        content_lines.append("")
        
        # Document metadata section
        if document_data:
            send_status("metadata", "Adding document information...", 40)
            content_lines.append("DOCUMENT INFORMATION")
            content_lines.append("-" * 30)
            content_lines.append("")
            
            for field, value in document_data.items():
                content_lines.append(f"{field}: {value}")
            
            content_lines.append("")
            content_lines.append("=" * 60)
            content_lines.append("")
            time.sleep(0.3)
        
        # Process each section
        section_progress_start = 50
        section_progress_range = 40  # 50% to 90%
        
        for i, section in enumerate(sections):
            section_name = section.get('name', 'Untitled Section')
            section_draft = section.get('data', {}).get('draft', '')
            section_type = section.get('type', 'default')
            
            if not section_draft.strip():
                continue
            
            # Calculate progress for this section
            section_progress = section_progress_start + int((i / len(sections)) * section_progress_range)
            send_status("processing", f"Processing {section_name} section...", section_progress)
            
            # Section header
            content_lines.append(section_name.upper())
            content_lines.append("=" * len(section_name))
            content_lines.append("")
            
            # Clean and format section content with section type context
            cleaned_content = self._clean_section_content(section_draft, section_type)
            content_lines.append(cleaned_content)
            
            content_lines.append("")
            content_lines.append("-" * 40)
            content_lines.append("")
            
            time.sleep(0.4)  # Simulate processing time per section
        
        # Document footer
        send_status("finalizing", "Finalizing document...", 90)
        content_lines.append("=" * 60)
        content_lines.append("Generated by CRAFT - Document Planning & Drafting")
        content_lines.append("https://github.com/your-repo/craft")
        content_lines.append("=" * 60)
        
        time.sleep(0.3)
        
        final_content = "\n".join(content_lines)
        send_status("complete", "Document generation complete!", 100)
        
        return final_content
    
    def generate_txt_document(self, document_id: str, document_data: dict, sections: list) -> str:
        """
        Generate a formatted text document from document data and sections (legacy method)
        """
        return self.generate_txt_document_with_progress(document_id, document_data, sections, None)
    
    def _clean_section_content(self, content: str, section_type: str = 'default') -> str:
        """
        Clean section content by removing generation markers and formatting
        
        Args:
            content: Raw section draft content
            section_type: Type of section for appropriate formatting
            
        Returns:
            Cleaned and formatted content
        """
        # Check if content is JSON (for table and risk sections)
        try:
            table_data = json.loads(content)
            if 'rows' in table_data:
                # Format table data as a text table with appropriate columns
                return self._format_table_as_text(table_data, section_type)
        except (json.JSONDecodeError, TypeError):
            # Not JSON, process as regular text
            pass
        
        lines = content.split('\n')
        cleaned_lines = []
        
        for line in lines:
            # Remove generation markers like [Generated draft - review and refine as needed]
            if line.strip().startswith('[') and line.strip().endswith(']'):
                continue
            
            # Clean any other markers
            cleaned_line = line.strip()
            if cleaned_line:
                cleaned_lines.append(cleaned_line)
            elif cleaned_lines and cleaned_lines[-1]:  # Preserve paragraph breaks
                cleaned_lines.append("")
        
        # Join with proper paragraph spacing
        formatted_content = []
        for i, line in enumerate(cleaned_lines):
            if line == "":
                if formatted_content and formatted_content[-1] != "":
                    formatted_content.append("")
            else:
                formatted_content.append(line)
        
        return "\n".join(formatted_content)
    
    def _format_table_as_text(self, table_data: dict, section_type: str = 'table') -> str:
        """
        Format table JSON data as a text table
        
        Args:
            table_data: Dictionary with 'rows' containing table data
            section_type: Type of section ('table' for limitations, 'risk' for risk issues)
            
        Returns:
            Formatted text table
        """
        if not table_data.get('rows'):
            return "Empty table"
        
        # Define column headers, keys, and widths based on section type
        if section_type == 'risk':
            # Model Risk Issues columns: (display_name, json_key, width)
            columns = [
                ('Risk Issue', 'item', 25),
                ('Description', 'description', 40),
                ('Likelihood', 'quantity', 12),
                ('Risk Level', 'status', 12),
                ('Controls', 'notes', 30)
            ]
        else:
            # Model Limitations columns (default): (display_name, json_key, width)
            columns = [
                ('Limitation', 'item', 25),
                ('Description', 'description', 40),
                ('Severity', 'quantity', 10),
                ('Impact', 'status', 15),
                ('Mitigation', 'notes', 30)
            ]
        
        lines = []
        
        # Create header row
        header = "|"
        separator = "|"
        for col_name, col_key, width in columns:
            header += f" {col_name.ljust(width)} |"
            separator += "-" * (width + 2) + "|"
        
        lines.append(header)
        lines.append(separator)
        
        # Add data rows
        for row in table_data['rows']:
            row_line = "|"
            for col_name, col_key, width in columns:
                value = str(row.get(col_key, '-'))
                # Truncate if too long
                if len(value) > width:
                    value = value[:width-3] + "..."
                row_line += f" {value.ljust(width)} |"
            lines.append(row_line)
        
        # Add footer with row count
        lines.append(separator)
        lines.append(f"Total rows: {len(table_data['rows'])}")
        
        return "\n".join(lines)
    
    def create_temporary_file(self, content: str, document_id: str) -> str:
        """
        Create a temporary file with the document content
        
        Args:
            content: The document content
            document_id: Document ID for filename
            
        Returns:
            Path to the temporary file
        """
        # Create a temporary file
        fd, temp_path = tempfile.mkstemp(suffix='.txt', prefix=f'document_{document_id}_')
        
        try:
            with os.fdopen(fd, 'w', encoding='utf-8') as temp_file:
                temp_file.write(content)
            return temp_path
        except Exception as e:
            # Clean up the file descriptor if writing fails
            os.close(fd)
            raise e
    
    def get_filename(self, document_id: str) -> str:
        """
        Generate a filename for the document
        
        Args:
            document_id: The document ID
            
        Returns:
            Suggested filename
        """
        safe_id = "".join(c for c in document_id if c.isalnum() or c in ('-', '_'))
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        return f"document_{safe_id}_{timestamp}.txt"